# 网络模型
> OSI模型
> - 应用层（application layer）  #http、https、ftp、telnet、ssh、smtp、pop3
> - 表示层（presentation layer）  #把数据转换为能与接收者的系统格式兼容并适合传输的格式
> - 会话层（session layer） #负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接
> - 传输层（transport layer） #把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。传输控制协议：tcp，udp
> - 网络层（network layer） #决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。互联网协议：ip
> - 链路层（data link layer）  #负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。以太网（ethernet），无限局域网（WIFI）和通用分组无限服务（GPRS）
>   - 数据链表头（DLH）包含了物理地址和错误侦测以及改错的方法。
>   - 数据链表尾（DLT）是一串指示数据包末端的字符串。
> - 物理层 （physical layer）  #在局部局域网上传送数据帧（data frame），负责管理计算机通信设备和网络媒体之间的互通。包括了针脚，电压，线缆规范，集线器，中继器，网卡，主机适配器。

# showtime
> ```
>     cd /proc/$$/fd  #进去当前进程的文件描述符目录
>     exec 8<> /dev/tcp/www.baidu.com/80  #创建文件描述符8，并且输入输出指向磁盘目录
>     ll  #可见8文件描述符指向socket，可知已经过三次握手建立连接
>     echo -e 'GET / HTTP/1.0\n' >& 8  #将'GET / HTTP/1.0输出到文件描述符8，其中字符串是http协议中规定的最小请求头
>     cat 0<& 8  #输出文件描述符8的内容，执行可见获取了百度页面内容
> ```
> 1. 建立连接
> 2. 传输数据（http协议：规范标准）
> 
> - 应用层 （用户态）
>   - 数据格式化
> - 传输层 （内核态）
>   - netstat -natp（传输层表）
>   - 创建数据包
>   - socket把协议抽象出统一的接口，建立socket连接能建立三次握手
> - 网络层 （内核态）
>   - route -n（网络层表）
> - 链路层 （内核态）
>   - arp -a（链路层表）
> - 物理层 （内核态）

# 应用层
> ## HTTP协议：【data】

# 传输层
> ## TCP协议：【【TCP】【data】】
> - 一种面向连接的、可靠的、基于字节流的传输层通信协议
> - 三次握手 -> 数据传输 -> 四次分手
>   - 最小粒度，不可分割：假想：一个client，多个server负载均衡，第一次握手打在server1，第三次握手却打在server2，大问题！！
> - 连接断开并不是物理上断开了，连接断开本质上是资源的释放
>   - 如何建立连接 => 三次握手
>       - 为何是三次：本质上双方确认是否【能够】通信（输入输出）成功
>           1. 发送方发送，接收方接收：
>           2. 接收方发送，发送方接收：发送方输入成功，发送方输出成功
>           3. 发送方发送，接收方接收：接收方输入成功，接收方输出成功
>       - 三次握手完成后，双方才通知应用层占用资源，开启线程
>   - 如何断开连接 => 四次分手
>       - 为何需要四次分手
>           1. 资源有限，不能无限增长资源
>           2. 连接断开，需要双方确认，以确保数据已经传输完毕
>       - 为何是四次：本质上双方确认是【同意】断开通信
>           1. 发送方发送，接收方接收：
>           2. 接收方发送，发送方接收：发送方断开信息发送成功（发送方知道对方已收到要断开的通知）
>           3. 接收方发送，发送方接收：发送方确认可以断开连接（发送方知道对方同意断开连接）
>           4. 发送方发送，接收方接收：接收方确认可以断开连接（接收方知道对方同意断开连接）
>   - 如何确认可靠
>       - 三次握手和四次分手
>       - 数据发送后，会收到确认
>   - 偷懒的tcp（tcp的优化，可能导致三次握手和数据传输界限不明确）
>       - 在第三次握手的时候，会带着数据一并发送
>       - 在数据传输的时候，确认包会带着数据一并发送（就是不断地确认，确认，确认...）

# 网络层
> ## IP协议：【【IP】【TCP】【data】】
> ```
>   cat /etc/sysconfig/network-scripts/ifconfig-XXX
>       TYPE=Ethernet  #以太网
>       IPADDR  #IP地址
>       NETMASK  #子网掩码，与IPADDR作位与运算，得到网络号
>       GATEWAY  #网关
>       DNS  #domain name system，域名系统，域名解析，解析域名与IP的映射（全网的）
> ```
> - 网络层任务：找到目标地址，方案：
>   1. 所有机器自己记录所有地址的数据，数据海量，速度过慢
>   2. IP协议：下一跳机制：只记录某个范围内数据 => 通过路由找到下一个范围内数据。。。（被抨击，存在丢包问题，可经过试验没问题）
> - IP协议  
>   ```
>       ping www.baidu.com
>   ```
>   1. 通过DNS获取目标IP
>   2. 通过目标IP，与Genmask（子网掩码）作位与运算，再与Destination（网络号）匹配，获得最终Gateway（网关）  
>   ![alt 路由表](src/picture/route.jpeg)
>       - 当匹配到Gateway为0.0.0.0时，可以直接跟目标地址通信。当匹配到的Gateway非0.0.0.0时，需要跳到下个路由。
>       - Genmask为0.0.0.0的是默认网关，一般是路由器地址
> - PS：从某台设备出发，经过一个个路由，汇集到运营商ISP（电信、移动等）管理的路由（运营商会有一个网络管理队伍，制定好详细的路由规则），经过这个路由后，就能正确地跳到其他路由。  
>   需要人工配置
>   ```
>       route add -host [ip]          gw    [ip]
>                 主机  主机ip         网关  网关ip
>       route add -net  [ip/num]      gw    [ip]
>                 网络  网络ip/掩码位数 网关  网关ip
>   ```

# 链路层
> ## ARP协议：解析IP与网卡硬件地址的映射（局域网）：【【ARP】【IP】【TCP】【data】】
> ![alt 链路表](src/picture/arp.jpeg)  
> 通过网关地址，转换为网卡硬件地址，向下层传递
> - ARP（address resolution protocol）原理
>   1. 当需要发送请求时，会查看ARP缓存，如果找到映射直接使用
>   2. 若找不到映射，将会向本地网络广播ARP请求（当前MAC地址+源IP+下一跳MAC地址（FFFFFFFF）+目标IP）  
>   3. 本地网络上每台机器接收到ARP请求并验证是否与ARP请求匹配，如果不匹配，直接丢弃
>   4. 如果某台机器匹配，将ARP数据缓存起来，并且直接回复ARP请求。
>   5. 源主机收到ARP回复后，将ARP数据缓存起来，然后使用
>   6. 因此ARP协议是建立在本地网络互相信任的基础上的，不需要人工配置
> - 实质上只有计算机的网卡激活，会主动通告本地网络自己的信息（主动广播ARP请求）
> - 交换机会学习记录ARP请求，缓存ARP信息
>

# 光与电
> 光速在无介质情况下传输最快
> 光缆中会减速，不过稳定，带宽高，适合长距离传输
> 电缆比光缆快，不过信号衰减得快，带宽没光缆高

# 负载均衡产生原因
> - 单个应用容器无法承载大量请求，需要扩充多个应用容器来分担请求
> - 基于网络工程原则，多个服务器建立连接时，无法共享一个IP，故需要一个中间件来承接转发
> - 单个中间件为何能承载大量请求：足够快
>   - 应用容器慢原因：1、处于应用层，经过的层数最多，2、应用层有个用户态和内核态的切换（某些应用容器一般还在操作系统上还建立了自己的虚拟机，还需要虚拟机内存与内核内存的拷贝）
>   - 中间件实现猜想：1、用户态和内核态的切换，不够快，至少来到传输层，2、建立握手时间，不够快，至少来到网络层，3、网络层，能直接转发数据包（满足请求转发需要），可能就比网线慢，应该够快了
> - 中间件处于网络层存在问题
>   1. 不知道数据内容，所以中间件无法感知要转发给谁，要达到发给谁都一样（服务器对中间件来说是一致的、镜像的）
>
> - 7层负载与4层负载区别
>   - 7层是为了业务转发，需要达到应用层知道数据内容，所以7层负载后面对接的可以是不一样的服务
>   - 4层是为了流量转发，需要达到网络层知道ip，所以4层负载后面对接的是一样的服务
> 
> - 使用中间件问题
>    - 客户端直接请求到4层负载的ip地址，所以请求数据包的目标IP是4层负载的地址，就算4层负载把请求数据包转发了，数据包的目标IP不是真实处理的服务器IP，真实服务器会把请求丢弃
>    - 解决方案：NAT

# NAT （Network Address Translation）3层
> - 猜想：如何区分不同的请求
>       - 区分不同请求：四元组原则：源IP+源端口+目标IP+目标端口，不过其中一端IP+端口是固定的，只能通过改变另一端IP/端口
>           - 替换IP：将非固定端IP替换成对外的公网IP
>       - 当多个不同的IP同时访问同一个IP+端口时，源IP+目标IP+目标端口无法定位到唯一请求了，因此需要同时改变源IP+源端口
>           - 替换端口：将源IP替换成随机的端口号，并在记录在NAT表
> - 分类：
>   - 替换源地址：S-NAT
>   - 替换目标地址：D-NAT
> - 存在缺点，NAT作为唯一的出入口，所有请求都经由NAT路由器
>   - 请求一般是非对称的，上行小（请求数据量少），下行大（返回数据量大），带宽瓶颈
>   - 算力问题：当数据量大时，数据包地址的替换也需要大量的算力
> - 解决缺陷方案猜想：
>   - 请求的非对称性，算力问题：NAT路由进，真实服务器出，减少NAT路由压力
>   - 解决方案：DR

# DR（Direct Routing）直接路由 2层
> - 猜想：如何能更快地转发不同的请求
>   - 请求的转发，一般来说都是根据目标IP，通过ARP来寻找MAC地址映射去到不同的机器。实际上可以直接干预MAC的拼接，目标IP不变，指定MAC地址。
>   - 要想机器不抛弃请求，必须要让机器认为承认自己的IP是请求的目标IP，同时也对其他机器不承认自己是请求的目标IP。
>       1. 承认自己的IP是请求的目标IP：LO：回环形虚拟网卡添加上目标IP
>       2. 其他机器不承认自己是请求的目标IP：隐藏配置的目标IP，在虚拟网卡添加目标IP  
>       3. 一台机器上能有多个网卡（物理+虚拟），每个网卡上能配置多个地址（IP）
>         kernel parameter:/proc/sys/net/ipv4/conf/* 
>       - arp_ignore：控制系统收到外部arp请求时，是否要返回arp响应  
>           0：请求到达的【机器上所有网卡】地址有匹配的就响应  
>           ![alt arg_ignore_0](src/picture/arp_ignore_0.png)  
>           1：请求到达的【网卡】地址有匹配的就响应  
>           ![alt arg_ignore_1](src/picture/arp_ignore_1.png)  
>       - arp_announce：控制系统在对外发送arp请求时，如何选择arp请求数据包的源IP地址  
>           0：可使用机器上所有网卡的任一IP作为arp请求的源IP，默认arp请求的目标地址  
>           ![alt arg_announce_0](src/picture/arp_announce_0.png)  
>           1：尽量避免使用不属于该发送网卡子网的本地地址作为arp请求的源IP，匹配失败跳到2配置
>           2：忽略IP数据包的源IP地址，选择该发送网卡上最适合的IP作为arp请求的源IP。
>           ![alt arg_announce_2](src/picture/arp_announce_2.png)  
>   - 因此需要对ARP作改造，同时因为基于ARP，所以需要基于同一局域网内。

# TUN 隧道
> - 产生原因：负载均衡后面的机器不在同一个局域网
> - 原理：在原有的3层网络数据包的基础上，再包裹一层网络源地址和目标地址，让数据包达到目标地址
>   - 类比案例：VPN、翻墙

# LVS
> 负载策略：（关于均衡策略的实现猜想，通过拆包偷窥里面的数据，来缺失连接的建立和断开）
>   - 静态
>       1. rr（轮询）
>       2. wwr
>       3. dh
>       4. sh
>   - 动态
>       1. lc（最少连接）
>       2. wlc（加权最少连接）
>       3. sed（最短期望延迟）
>       4. nq（never queue）
>       5. LBLC（基于本地的最少连接）
>       6. DH
>       7. LBLCR（基于本地的带复制功能的最少连接）
> - lvs代码已整合到linux内核里，不过需要安装调用接口ipvs```yum install ipvsadm -y```  
> - lvs配置：
>   1. lvs负载均衡直接转发的服务器
>       1. 修改内核（改造arp协议），需先配置内核参数，再设置网卡
>           ```
>               echo 1 > /proc/sys/net/ipv4/conf/*/arp_ignore
>               echo 2 > /proc/sys/net/ipv4/conf/*/arp_announce
>           ```
>       2. 设置访问IP
>           ```
>               ifconfig lo:2 xxx.xxx.xxx.xxx(访问IP) netmark 255.255.255.255
>               ifconfig lo:2 down 删除网卡配置
>           ```
>   2. lvs负载均衡服务器
>       1. 设置访问IP
>           ```
>               ifconfig eth0:2 xxx.xxx.xxx.xxx(访问IP) netmark 255.255.255.0
>           ```
>       2. 按照lvs工具
>           ```
>               yum install -y ipvsadm
>               ipvsadm -A -t xxx.xxx.xxx.xxx(访问IP):[port] -s rr
>               ipvsadm -a -t xxx.xxx.xxx.xxx(访问IP):[port] -r XXX.XXX.XXX.XXX(转发服务器IP) -g(轮询) -w(权重) 1
>               ipvsadm -C 删除lvs配置
>           ```
>   3. 定位问题
>       - lvs负载均衡服务器
>           - netstat -natp  **因为没有建立连接，查看不多socket**
>           - ipvsadm -lnc  **查看lvs连接情况，lvs实际上不会建立连接，只是通过偷窥数据包来判断连接情况**  
>         
>               | pro | expire | state | source | virtual | destination |
>               | --- | --- | --- | --- | --- | --- |  
>               | 协议 | 过期时间 | 状态 | 源地址 | lvs配置地址 | 目标地址 |  
>               当state为wait_timeout时，一般连接建立正常
>               当state为sync_recv时，说明转发后有问题，目标地址没有接收数据包
>       - lvs负载均衡直接转发的服务器
>           - netstat -natp  **因为没有建立连接，查看不多socket**

# keepalived
> - 问题：
>   - lvs故障，整个系统无法请求：单点故障
>   - web服务故障，部分请求异常：lvs静态配置
> - 方案思路：
>   - 单点故障：多点
>       1. 主备：主服务器提供服务，备服务器赞不提供服务。主服务器挂掉，备用服务器立马顶上
>       2. 主从：主服务器和从服务器都提供服务，不过主服务器和从服务器提供的服务不一样（主服务器需要主备，主服务器存在单点故障）
>       3. 主主：多台服务同时提供服务（LVS需要DNS来解决IP问题）
> - 多点方式：
>   - 感知
>       1. 备机定期主动轮询主机状态（缺点：主机响应压力）
>       2. 主机定期主动广播主机状态
>   - 效率
>       1. 权重（不用竞争，进行推选）
> - 如何得知服务器挂掉
>   - ping：处于网络层，只能知道网络通不通，不知道上层服务是否能够提供正常服务
>   - 访问一下：（验证应用层协议=>发请求，返回200）
> - keepalived作用
>   - 监控自己
>   - 选举
>   - 配置
> - 猜想keepalived拥有功能
>   1. keepalived对内：keepalived主备
>   2. keepalived对外：检测外部服务健康状态
>   3. keepalived对lvs：内置lvs功能（ipvsadm+ifconfig）
> - keepalived配置
>   1. lvs负载均衡服务器
>       1. 安装keepalived
>           ```
>               yum install -y keepalived ipvsadm
>           ```
>       2. keepalived配置
>           ```
>               vi /etc/keepalived/keepalived.conf
>                  vrrp_instance [masterName] {} **虚拟路由冗余协议实例**
>                       state [MASTER/BACKUP]  **主机填MASTER，备机填BACKUP**
>                       interface [网卡号]
>                       virtual_router_id [虚拟路由] **用于区分不同的keepalived集群，同一个keepalived集群相同**
>                       priority [0-100] **权重，值越大，权重越大，主机权重比备机大**
>                       virtual_ipaddress {}
>                           [IPADDR]/[MASK] brd [IPADDR] dev [string] scope [scope] label [label]
>                           192.168.1.1/24 dev eth1 label eth1:1 **同ipconfig配置虚拟网卡**
>                   virtual_server [ip] [port] {}  **虚拟服务，lvs功能**
>                       lb_algo [负载策略]  **rr**
>                       lb_kind [负载类型]  **NAT，DR**
>                       persistence_timeout [second]  **持久化时长，数据包保持向其中一个服务的持续时间，以免多台服务接收请求浪费资源，测试时可配置为0**
>                       protocol [TCP]
>                       real_server [ip] [port] {}  **真实服务**
>                           weight [number]  **权重**
>                           [SSL_GET/HTTP_GET] {}  **检测真实服务健康状态**
>                               url {} 
>                                   path [string]  **访问路径**
>                                   digest [string]
>                                   status_code [int]
>           ```
>       3. 启动keepalived
>           ```
>               service keepalived start
>           ```
>       4. 校验keepalived是否生效
>           ```
>               ifconfig
>               ipvsadm -ln
>           ```
>       5. PS
>           - master机down，backup机ifconfig才显示（主机宕机，备机ip漂移）
>           - ipvsadm 主备都持续监测real_server健康状态
>           - master机up，backup机down（主机恢复，备机下线，基于权重）
> - keepalived问题
>   1. keepalived启动后，通过```ps ef```命令可看到有一条主进程（主程序），多条子进程（监测多个服务健康）  
>   2. 当keepalived相关进程忽然挂掉（主机直接```kill -9```），虚拟ip会不清掉（主进程无法回收资源），ipvsadm也不会清掉（子进程无法回收资源）  
>   3. 备机收不到主机定期健康报告，自动上线，导致客户端的请求数据包无法正常转发，出现请求失败（破坏tcp三次握手，四次分手原子性）
>   4. 起因：需要依赖keepalived进程的正常运行和结束
>   5. 方案：无限套娃（上层无限套keepalived）
>   6. 结论：高可用不可靠
>   7. 其他可靠高可用技术：zookeeper